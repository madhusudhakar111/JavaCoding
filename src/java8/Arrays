// 1 Find the Largest & Smallest element in an array

		int[] arr = { 4, 2, 9, 1, 7 };

		int largest = Integer.MIN_VALUE;
		int secondLargest = Integer.MIN_VALUE;

		int smallest = Integer.MAX_VALUE;
		int secondSmallest = Integer.MAX_VALUE;

		for (int n : arr) {

			if (n > largest) {
				secondLargest = largest;
				largest = n;

			} else if (n > secondLargest) {
				secondLargest = n;
			}

			if (n < smallest) {
				secondSmallest = smallest;
				smallest = n;
			} else if (n < secondSmallest) {
				secondSmallest = n;
			}

		}

		System.out.println(largest);
		System.out.println(secondLargest);

		System.out.println(smallest);
		System.out.println(secondSmallest);


// 2 . Reverse an Array  Input: [1, 2, 3, 4] Output: [4, 3, 2, 1]
		int arr[] = { 1, 2, 3, 4 }; 

		int left = 0;
		int right = arr.length - 1;

		while (left < right) {
			int temp = arr[right];
			arr[right] = arr[left];
			arr[left] = temp;
			left++;
			right--;

		}
		System.out.println(Arrays.toString(arr)); // [4, 3, 2, 1]


// 3. Move Zeros to left Input: [0,1,0,3,12] Output: [0, 0, 3, 12, 1]

		int arr[] = {0,1,0,3,12};
		int left = 0;
		int right = arr.length-1;
		
		while(left < right) {
			if(arr[left] == 0) {
				left++;
			} else {
				int temp = arr[right];
				arr[right] = arr[left];
				arr[left] = temp;
				right--;
			}
		}
		
		System.out.println(Arrays.toString(arr)); // [0, 0, 3, 12, 1]

// 4. Check if Array is Sorted Input: [1,2,3,4] Output: true
		
		int arr[] = {1,2,3,4};
		
		boolean flag = true;
		
		for(int i = 0; i<arr.length-2; i++) {
			if(arr[i] > arr[i+1] ) {
				flag = false;
			}
		}
		
		System.out.println(flag);  

// 5.  You are on a plane and you can watch two movies during this flight. You are given List<Integer> movieDurations which includes all the movie durations. You are also given duration of the flight which is in d minutes. Now, you need to pick two movies and the total duration of two movies is less than or equal to (d - 30min). Find the pair of movies with the longest total duration and return their indexes. If multiple found, return the pair with longest movie. Example1: Input: movieDurations = [90, 85, 75, 60, 120, 150, 125], d = 250 Output: [0, 6] Explaination: movieDuration[0] + movieDuration[6] = 90 + 125 = 215 is the maximum number within 220 (250 min - 30 min).
// Sum of the two smallest numbers is < K

		int k = 250 - 30; // 220

		int[] arr = { 90, 85, 75, 60, 120, 150, 125 };
		Map<Integer, Integer> map = new TreeMap<>();

		for (int i = 0; i <= arr.length - 1; i++) {
			map.put(arr[i], i);
		}

		System.out.println(map);

		int arr1[] = map.entrySet().stream().mapToInt(e -> e.getKey()).toArray();
		System.out.println(Arrays.toString(arr1));

		// [60, 75, 85, 90, 120, 150]

		int left = 0;
		int right = arr1.length - 1;
		int max = Integer.MIN_VALUE;

		int leftIndex = 0;
		int rightIndex = 0;

		while (left < right) {

			int sum = arr1[left] + arr1[right];
			if (sum <= k) {
				max = Math.max(max, sum);
				if (max >= sum) {
					System.out.println(arr1[left] + ", " + arr1[right]);
					leftIndex = map.get(arr1[left]);
					rightIndex = map.get(arr1[right]);
				}
				left++;
			} else {
				right--;
			}

		}

		System.out.println(max);

		System.out.println(leftIndex + "," + rightIndex);
//6. Pair with Given Sum [2,7,11,15], sum=9
		int arr[] = {2, 7, 11, 15};
		Set<Integer> set = new HashSet<>();
		int sum  = 9;
		
		for(int x:arr) {
			if(set.contains(sum-x)) {
				System.out.print("Found");
				break;
			} else {
				set.add(x);
			}
		}

//7. Maximum Subarray Sum (Kadane) Input: [-2,1,-3,4,-1,2,1] Output: 6
		int arr[] = { -2, 1, -3, 4, -1, 2, 1 };
		int maxSubArraySum = Integer.MIN_VALUE;
		int maxPrefixSum = 0;

		for (int n : arr) {
			maxPrefixSum = Math.max(n, maxPrefixSum + n);
			maxSubArraySum = Math.max(maxSubArraySum, maxPrefixSum);
		}

		System.out.println(maxSubArraySum); // 6
// 8. Count Frequency Input: [1,2,2,3,3,3] Output: {1=1,2=2,3=3}

		int arr[] = { 1,2,2,3,3,3 };
		Map<Integer, Integer> map = new LinkedHashMap<>();
		
		for(int n:arr) {
			map.put(n, map.getOrDefault(1, 0)+1);
		}
		
		System.out.println(map);
		
		Map<Integer, Long> m1 = Arrays.stream(arr).boxed().collect(Collectors.groupingBy(e -> e, LinkedHashMap::new, Collectors.counting()));
		System.out.println(m1);
//9. Intersection of Two Arrays Input: [1,2,2,3] & [2,2] Output: [2]

		int arr1[] = { 1, 2, 2, 3 };
		int arr2[] = { 2, 2 };

		Set<Integer> s1 = new HashSet<>();
		Set<Integer> s2 = new HashSet<>();

		for (int n : arr1) {
			s1.add(n);
		}

		for (int n : arr2) {
			if (s1.contains(n)) {
				s2.add(n);
			}
		}

		System.out.println(s2);

	//10. Find All Leaders Input: [16,17,4,3,5,2] Output: 17 5 2 // similar logic to next greater number

	    int arr[] = { 16, 17, 4, 3, 5, 2 };
		Stack<Integer> stack = new Stack<>();
		stack.push(arr[arr.length - 1]);
		
		for (int i = arr.length - 2; i >= 0; i--) {
			if (arr[i] > stack.peek()) {
				stack.push(arr[i]);
			}
		}
		System.out.println(stack.reversed());

 // 11. Longest Consecutive Sequence Input: [100,4,200,1,3,2] Output: 4 i.e 1,2,3,4

		int arr[] = { 100, 4, 200, 1, 3, 2 };
		Set<Integer> set = new HashSet<>();
		for (int n : arr) {
			set.add(n);
		}
		int longestConsequence = 1;
		for (int number : set) {
			// Better to check previous value should not available in set  if(!set.contains(number-1)) { }
			int currentSecurence = 1;

			while (set.contains(number + 1)) {
				number++;
				currentSecurence++;
			}
			longestConsequence = Math.max(currentSecurence, longestConsequence);
		}
		System.out.println(longestConsequence); // 4 i.e 1,2,3,4


//12. Find Kth Largest Input: [3,2,1,5,6,4], k=2 Output: 5
		int k =2;
		int arr[] = {3,2,1,5,6,4};   //[ 1, 3, 2, 5, 6, 4]
		
		PriorityQueue<Integer> q = new PriorityQueue<>();
		//PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());
		
		for(int n : arr) {
			q.offer(n);   // adding 
			if(q.size() > k) {
				q.poll();  // removing
			}
				
		}
		
		System.out.println(q.peek());

//13. Sort 0s, 1s, 2s (Dutch Flag) Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2]
		int arr[] = { 2, 0, 2, 1, 1, 0 };

		int left = 0;
		int middle = 0;
		int right = arr.length - 1;

		while (middle <= right) {

			if (arr[middle] == 0) {

				int temp = arr[left];
				arr[left] = arr[middle];
				arr[middle] = temp;

				left++;
				middle++;

			} else if (arr[middle] == 1) {
				middle++;
			} else if (arr[middle] == 2) {
				int temp = arr[right];
				arr[right] = arr[middle];
				arr[middle] = temp;
				right--;
			}

		}

		System.out.println(Arrays.toString(arr));
		
//14. Next greater element 

		int arr[] = {4, 6, 9, 3, 8, 7, 5, 4, 3, 2};
		
		int result[] = new int[arr.length];
		
		Stack<Integer> stack = new Stack<>();
		
		stack.push(arr[arr.length-1]);
		result[arr.length-1] = -1;
		
		
		for(int i = arr.length-2 ; i>=0; i-- ) {
			
			int cur = arr[i];
			
			while(!stack.isEmpty() && stack.peek() <= cur) {
				stack.pop();
			}
			
			result[i] = stack.isEmpty() ? -1 : stack.peek(); 
			stack.push(arr[i]);
			
		}
		
		System.out.println(Arrays.toString(result)); // [6, 9, -1, 8, -1, -1, -1, -1, -1, -1]


//15. Best Time to Buy and Sell Stock – ONE Transaction Input: [7, 1, 5, 3, 6, 4] Output: 5
		//  Explanation: Buy at 1, Sell at 6
		
		int arr[] = { 7, 1, 5, 3, 6, 4 };

		int minPrice = Integer.MAX_VALUE;
		int maxProfit = 0;

		for (int n : arr) {
			minPrice = Math.min(minPrice, n);
			maxProfit = Math.max(maxProfit, n - minPrice);
		}

		System.out.println(maxProfit);  // 5

//16. Best Time to Buy and Sell Stock – At Most 2 Transactions Input: [7, 1, 5, 3, 6, 4] Output: 5
		
		int arr[] = { 7, 1, 5, 3, 6, 4 };
		int leftarr[] = new int[arr.length];
		int rightarr[] = new int[arr.length];
		
		int minPrice = Integer.MAX_VALUE;
		int maxPrice = Integer.MIN_VALUE;
		
		int leftMaxProfit = 0;
		int rightMaxProfit = 0;
		
		int maxProfit = 0;
		
		for (int i=0; i<=arr.length-1; i++) {
			int currentPrice = arr[i];
			minPrice = Math.min(minPrice, currentPrice);
			leftMaxProfit =  Math.max(leftMaxProfit, currentPrice-minPrice);
			leftarr[i] = leftMaxProfit;
		}
		
		for (int i=arr.length-1; i>=0; i--) {
			int currentPrice = arr[i];
			maxPrice = Math.max(maxPrice, currentPrice);
			rightMaxProfit=  Math.max(rightMaxProfit, maxPrice-currentPrice);
			rightarr[i] = rightMaxProfit;
		}
		
		for(int i=0; i<=arr.length-1; i++) {
			maxProfit = Math.max(maxProfit, leftarr[i]+rightarr[i]);
		}
		
		System.out.println(maxProfit);  // 7

//17. Count inversion Brutforce oproach
		
		int arr[] = {8, 4, 2, 1, 3, 7, 5, 6};
		
		int count = 0;
		for(int i=0; i<=arr.length-1; i++) {
			for(int j=i+1; j<=arr.length-1; j++) {
				if(arr[i] > arr[j]) {
					count++;
				}
			}
		}
		System.out.println(count);

// 18. Merge two sorted array into single sorted array o/p : [1, 2, 3, 4, 5, 6, 7, 8]

		int arr1[] = { 1, 3, 5, 7 };
		int arr2[] = { 2, 4, 6, 8 };

		int mergedArray[] = new int[arr1.length + arr2.length];

		int i = 0;
		int j = 0;
		int k = 0;

		while (i < arr1.length && j < arr2.length) {

			if (arr1[i] < arr2[j]) {
				mergedArray[k] = arr1[i];
				k++;
				i++;
			} else if (arr1[j] < arr2[i]) {
				mergedArray[k] = arr2[j];
				k++;
				j++;
			}

		}

		while (i < arr1.length) {
			mergedArray[k] = arr1[i];
			i++;
			k++;
		}

		while (j < arr2.length) {
			mergedArray[k] = arr2[j];
			j++;
			k++;
		}

		System.out.println(Arrays.toString(mergedArray));

	// 19. Count Inversion between two sorted array's {1 ,3 ,5, 7} {2 ,4 ,6, 8} o/p : 6

		int arr1[] = { 1, 3, 5, 7 };
		int arr2[] = { 2, 4, 6, 8 };

		int i = 0;
		int j = 0;
		int count = 0;

		while (i < arr1.length && j < arr2.length) {

			if (arr1[i] < arr2[j]) {
				i++;
			} else {
				count += arr1.length - i;
				j++;
			}
		}
		System.out.println(count);

// 20. Merge sort Algorithm

public static int[] mergeTwoSortedArray(int[] leftArray, int[] rightArray, int mergedArray[]) {

		int i = 0;
		int j = 0;
		int k = 0;

		while (i < leftArray.length && j < rightArray.length) {

			if (leftArray[i] < rightArray[j]) {
				mergedArray[k] = leftArray[i];
				i++;
				k++;
			} else {
				mergedArray[k] = rightArray[j];
				j++;
				k++;
			}

		}

		while (i < leftArray.length) {
			mergedArray[k] = leftArray[i];
			i++;
			k++;
		}

		while (j < rightArray.length) {
			mergedArray[k] = rightArray[j];
			j++;
			k++;

		}

		return mergedArray;

	}

	public static void divide(int arr[]) {

		if (arr.length < 2) {
			return;
		}

		int mid = arr.length / 2;
		int leftArray[] = Arrays.copyOfRange(arr, 0, mid);
		int rightArray[] = Arrays.copyOfRange(arr, mid, arr.length);

		divide(leftArray);
		divide(rightArray);

		mergeTwoSortedArray(leftArray, rightArray, arr);

	}

	public static void main(String[] args) {

		int arr[] = { 4, 8, 12, 11, 13, 5, 6, 7 };
		divide(arr);
		System.out.println(Arrays.toString(arr)); //  [4, 5, 6, 7, 8, 11, 12, 13]

	}


// 21. Check if two arrays are equal
		int[] a = { 1, 2, 3, 4 };
		int[] b = { 1, 2, 3, 4 };

		// System.out.println(Arrays.equals(a, b)); // one way
		int i = 0;
		int j = 0;
		boolean flag = true;

		while (i < a.length && j < b.length) {
			if (a[i] != b[j]) {
				flag = false;
				break;
			}
			i++;
			j++;
		}
		System.out.println(flag);


// 22. Longest Subarray With Sum = K  O/p : 4
		
		//  First approach : sliding window . it works if no negative values. and interview wont satisfy with this
		int arr[] = {10, 5, 2, 7, 1, 9};
		int k = 15;
		int left =0;
		int sum = 0;
		int maxLength = 0;
		
		for (int right = 0; right < arr.length; right++) {

			sum = sum + arr[right];

			if (sum > k) {
				sum = sum - arr[left];
				left++;
			}

			if (sum == k) {
				int current_length = right - left + 1;
				maxLength = Math.max(maxLength, current_length);
			}

		}
		
		System.out.println(maxLength); // 4

------------------------------------------------------------------------------------------------------------------------------
//23 Longest Subarray With Sum = K O/p : 4
		------------------------------------------------------------------------------------------------------------------------------
		// First approach : sliding window . it works for non negative values.
		// interviewer will raise the cross questions on this by giving negative number
		// then follow the second approach
		------------------------------------------------------------------------------------------------------------------------------
		int arr[] = { 10, 5, 2, 7, 1, 9 };
		int k = 15;
		int left = 0;
		int sum = 0;
		int maxLength = 0;

		for (int right = 0; right < arr.length; right++) {

			sum = sum + arr[right];

			if (sum > k) {
				sum = sum - arr[left];
				left++;
			}

			if (sum == k) {
				int current_length = right - left + 1;
				maxLength = Math.max(maxLength, current_length);
			}

		}

		System.out.println(maxLength); // 4

		
		
		------------------------------------------------------------------------------------------------------------------------------
		// Second Approach : Prefix Sum + HashMap approach
		------------------------------------------------------------------------------------------------------------------------------
		int arr[] = { 10, 5, 2, 7, 1, 9 }; // arr = [3, 4, 7, 2, -3, 1, 4, 2]
		int k = 15;

		int prefixSum = 0;
		int maxLength = 0;

		Map<Integer, Integer> map = new HashMap<>();

		for (int i = 0; i < arr.length - 1; i++) {

			int cur = arr[i];

			prefixSum += cur;

			if (prefixSum == k) {
				maxLength = i+1;
			}

			// sum = k --> sum-k = x find the x value in the map;   this is the main logic

			if (map.containsKey(prefixSum - k)) {
				maxLength = Math.max(maxLength, i - map.get(prefixSum - k));
			}

			map.put(prefixSum, i);

		}

		System.out.println(maxLength);  // 4


//24. Maximum sum subarray of size k  input arr = [2, 1, 5, 1, 3, 2] k = 3   o/p : 9 i.e [5,1,3]
		
		
		
		int arr[] = {2, 1, 5, 1, 3, 2};
		int k =3;
		
		
		int left = 0;
		int maxSum =0;
		
		int windowSum = 0;
		
		
		for(int right = 0; right<=arr.length-1; right++) {
			
			windowSum = windowSum+ arr[right];
			
			/**	if(right <= k-1) {
					maxSum = Math.max(maxSum, windowSum);
				} else {
					windowSum = windowSum- arr[left];
					left++;
					maxSum = Math.max(maxSum, windowSum);
				} 
			*/
			
			// re-write above if else condition
			
			if(right >= k-1) {
				maxSum = Math.max(maxSum, windowSum);
				windowSum = windowSum- arr[left];
				left++;
			}
			
		}
		
		System.out.println(maxSum); // 9


//25. Find the length of the smallest contiguous subarray whose sum is greater than or equal to k.	
//  input : arr = [2, 3, 1, 2, 4, 3]  , k = 7   ,  o/p: 2   ,  i.e [4,3] sum = 7 

		int arr[] = { 2, 3, 1, 2, 4, 3 };
		int k = 7;
 
		int left = 0;
		int windowSum = 0;
		int minLength = Integer.MAX_VALUE;

		for (int right = 0; right <= arr.length - 1; right++) {

			int cur = arr[right];
			windowSum = windowSum + cur;

			while (windowSum >= k) {
				minLength = Math.min(minLength, right - left + 1);
				windowSum = windowSum - arr[left];
				left++;
			}

		}

		System.out.println(minLength); // 2


// 26. Longest subarray with sum = 0   find the length of the longest contiguous subarray whose sum is exactly 0.
		//  input : {3, 4, -7, 1, 3, 3, 1, -4 };   o/p : 4 
		
		int arr[] = {3, 4, -7, 1, 3, 3, 1, -4 };  
		
		Map<Integer, Integer> map = new HashMap<>();
		
		int prefixSum = 0;
		int maxLength = 0;
		
		for(int i = 0; i<= arr.length-1; i++) {
			
			int cur = arr[i];
			prefixSum += cur;
			
			if(map.containsKey(prefixSum)) {
				maxLength = Math.max(maxLength, i-map.get(prefixSum));
			}
			map.put(prefixSum, i);
		}
		
		System.out.println(prefixSum);  // 4
