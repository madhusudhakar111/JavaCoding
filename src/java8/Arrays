// 1 Find the Largest & Smallest element in an array
		
		int[] arr = { 4, 2, 9, 1, 7 };

		int max = Integer.MIN_VALUE;
		int min = Integer.MAX_VALUE;

		int secondMax = Integer.MIN_VALUE;
		int secondMin = Integer.MAX_VALUE;

		for (int n : arr) {

			if (n > max) {
				secondMax = max; // previous max becomes second max
				max = n;
			} else if (n > secondMax) {
				secondMax = n;
			}

			if (n < min) {
				secondMin = min; // previous min becomes second min
				min = n;
			} else if (n < secondMin) {
				secondMin = n;
			}

		}

		System.out.println(max);  // 9 
		System.out.println(secondMax);  // 7

		System.out.println(secondMin);  //2
		System.out.println(min);  //1


// 2 . Reverse an Array  Input: [1, 2, 3, 4] Output: [4, 3, 2, 1]
		int arr[] = { 1, 2, 3, 4 }; 

		int left = 0;
		int right = arr.length - 1;

		while (left < right) {
			int temp = arr[right];
			arr[right] = arr[left];
			arr[left] = temp;
			left++;
			right--;

		}
		System.out.println(Arrays.toString(arr)); // [4, 3, 2, 1]


// 3. Move Zeros to left Input: [0,1,0,3,12] Output: [0, 0, 3, 12, 1]

		int arr[] = {0,1,0,3,12};
		int left = 0;
		int right = arr.length-1;
		
		while(left < right) {
			if(arr[left] == 0) {
				left++;
			} else {
				int temp = arr[right];
				arr[right] = arr[left];
				arr[left] = temp;
				right--;
			}
		}
		
		System.out.println(Arrays.toString(arr)); // [0, 0, 3, 12, 1]

// 4. Check if Array is Sorted Input: [1,2,3,4] Output: true
		
		int arr[] = {1,2,3,4};
		
		boolean flag = true;
		
		for(int i = 0; i<arr.length-2; i++) {
			if(arr[i] > arr[i+1] ) {
				flag = false;
			}
		}
		
		System.out.println(flag);  

// 5.  You are on a plane and you can watch two movies during this flight. You are given List<Integer> movieDurations which includes all the movie durations. You are also given duration of the flight which is in d minutes. Now, you need to pick two movies and the total duration of two movies is less than or equal to (d - 30min). Find the pair of movies with the longest total duration and return their indexes. If multiple found, return the pair with longest movie. Example1: Input: movieDurations = [90, 85, 75, 60, 120, 150, 125], d = 250 Output: [0, 6] Explaination: movieDuration[0] + movieDuration[6] = 90 + 125 = 215 is the maximum number within 220 (250 min - 30 min).
// Sum of the two smallest numbers is < K

		int k = 250 - 30; // 220

		int[] arr = { 90, 85, 75, 60, 120, 150, 125 };
		Map<Integer, Integer> map = new TreeMap<>();

		for (int i = 0; i <= arr.length - 1; i++) {
			map.put(arr[i], i);
		}

		System.out.println(map);

		int arr1[] = map.entrySet().stream().mapToInt(e -> e.getKey()).toArray();
		System.out.println(Arrays.toString(arr1));

		// [60, 75, 85, 90, 120, 150]

		int left = 0;
		int right = arr1.length - 1;
		int max = Integer.MIN_VALUE;

		int leftIndex = 0;
		int rightIndex = 0;

		while (left < right) {

			int sum = arr1[left] + arr1[right];
			if (sum <= k) {
				max = Math.max(max, sum);
				if (max >= sum) {
					System.out.println(arr1[left] + ", " + arr1[right]);
					leftIndex = map.get(arr1[left]);
					rightIndex = map.get(arr1[right]);
				}
				left++;
			} else {
				right--;
			}

		}

		System.out.println(max);

		System.out.println(leftIndex + "," + rightIndex);
//6. Pair with Given Sum [2,7,11,15], sum=9
		int arr[] = {2, 7, 11, 15};
		Set<Integer> set = new HashSet<>();
		int sum  = 9;
		
		for(int x:arr) {
			if(set.contains(sum-x)) {
				System.out.print("Found");
				break;
			} else {
				set.add(x);
			}
		}

//7. Maximum Subarray Sum (Kadane) Input: [-2,1,-3,4,-1,2,1] Output: 6
		int arr[] = { -2, 1, -3, 4, -1, 2, 1 };
		int maxSubArraySum = Integer.MIN_VALUE;
		int maxPrefixSum = 0;

		for (int n : arr) {
			maxPrefixSum = Math.max(n, maxPrefixSum + n);
			maxSubArraySum = Math.max(maxSubArraySum, maxPrefixSum);
		}

		System.out.println(maxSubArraySum); // 6
// 8. Count Frequency Input: [1,2,2,3,3,3] Output: {1=1,2=2,3=3}

		int arr[] = { 1,2,2,3,3,3 };
		Map<Integer, Integer> map = new LinkedHashMap<>();
		
		for(int n:arr) {
			map.put(n, map.getOrDefault(1, 0)+1);
		}
		
		System.out.println(map);
		
		Map<Integer, Long> m1 = Arrays.stream(arr).boxed().collect(Collectors.groupingBy(e -> e, LinkedHashMap::new, Collectors.counting()));
		System.out.println(m1);
//9. Intersection of Two Arrays Input: [1,2,2,3] & [2,2] Output: [2]

		int arr1[] = { 1, 2, 2, 3 };
		int arr2[] = { 2, 2 };

		Set<Integer> s1 = new HashSet<>();
		Set<Integer> s2 = new HashSet<>();

		for (int n : arr1) {
			s1.add(n);
		}

		for (int n : arr2) {
			if (s1.contains(n)) {
				s2.add(n);
			}
		}

		System.out.println(s2);

	//10. Find All Leaders Input: [16,17,4,3,5,2] Output: 17 5 2 // similar logic to next greater number

	    int arr[] = { 16, 17, 4, 3, 5, 2 };
		Stack<Integer> stack = new Stack<>();
		stack.push(arr[arr.length - 1]);
		
		for (int i = arr.length - 2; i >= 0; i--) {
			if (arr[i] > stack.peek()) {
				stack.push(arr[i]);
			}
		}
		System.out.println(stack.reversed());

 // 11. Longest Consecutive Sequence Input: [100,4,200,1,3,2] Output: 4

		int arr[] = { 100, 4, 200, 1, 3, 2 };
		Set<Integer> set = new HashSet<>();
		for (int n : arr) {
			set.add(n);
		}
		int longestConsequence = 1;
		for (int number : set) {
			// Better to check previous value should not available in set  if(!set.contains(number-1)) { }
			int currentSecurence = 1;

			while (set.contains(number + 1)) {
				number++;
				currentSecurence++;
			}
			longestConsequence = Math.max(currentSecurence, longestConsequence);
		}
		System.out.println(longestConsequence); // 4 i.e 1,2,3,4


//12. Find Kth Largest Input: [3,2,1,5,6,4], k=2 Output: 5
		int k =2;
		int arr[] = {3,2,1,5,6,4};   //[ 1, 3, 2, 5, 6, 4]
		
		PriorityQueue<Integer> q = new PriorityQueue<>();
		//PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());
		
		for(int n : arr) {
			q.offer(n);   // adding 
			if(q.size() > k) {
				q.poll();  // removing
			}
				
		}
		
		System.out.println(q.peek());

//13. Sort 0s, 1s, 2s (Dutch Flag) Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2]
		int arr[] = { 2, 0, 2, 1, 1, 0 };

		int left = 0;
		int cur = 0;
		int right = arr.length - 1;

		while (cur < right) {
			if (arr[cur] == 0) {
				arr[left] = arr[cur];
				left++;
				cur++;
			} else if (arr[cur] == 1) {
				cur++;
			} else if (arr[cur] == 2) {
				int temp = arr[right];
				arr[right] = arr[cur];
				arr[cur] = temp;
				right--;
			}
		}

		System.out.println(Arrays.toString(arr));
		
//14. Next greater element 

		int arr[] = {4, 6, 9, 3, 8, 7, 5, 4, 3, 2};
		
		int result[] = new int[arr.length];
		
		Stack<Integer> stack = new Stack<>();
		
		stack.push(arr[arr.length-1]);
		result[arr.length-1] = -1;
		
		
		for(int i = arr.length-2 ; i>=0; i-- ) {
			
			int cur = arr[i];
			
			while(!stack.isEmpty() && stack.peek() <= cur) {
				stack.pop();
			}
			
			result[i] = stack.isEmpty() ? -1 : stack.peek(); 
			stack.push(arr[i]);
			
		}
		
		System.out.println(Arrays.toString(result)); // [6, 9, -1, 8, -1, -1, -1, -1, -1, -1]
